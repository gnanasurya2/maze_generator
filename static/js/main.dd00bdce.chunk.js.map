{"version":3,"sources":["components/NewMaze.js","App.js","reportWebVitals.js","index.js","Maze.module.css"],"names":["Cells","NewMaze","props","useState","restart","setRestart","stack","setStack","current","setCurrent","numberOfVisited","setNumberOfVisited","numberOfPixel","pixelSize","wallSize","tracked","setTracked","canvasRef","useRef","Cell","x","y","this","rightWall","downWall","visited","display","console","log","fillWalls","side","ctx","getContext","fillStyle","fillRect","useEffect","findReverse","index","ele","length","diff","tracker","state","slice","color","loc","dir","width","height","onEnd","clearRect","canvas","left","up","right","down","mazeGenerator","neighbours","push","filter","findNeighbours","mazeController","selected","Math","floor","random","next","difference","removeWalls","setTimeout","last","newStack","spaceW","Pixels","spaceH","cell","ref","App","mazeToggle","showControls","setShowControls","setUp","setDown","setLeft","setRight","keyPressHandler","e","code","window","addEventListener","removeEventListener","className","onKeyDown","mazeState","styles","row","but","onClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.dd00bdce.chunk.js","sourcesContent":["import { useEffect, useRef, useState } from \"react\";\r\nlet Cells = [];\r\nconst NewMaze = (props) => {\r\n  const [restart, setRestart] = useState(true);\r\n  const [stack, setStack] = useState([]);\r\n  const [current, setCurrent] = useState(null);\r\n  const [numberOfVisited, setNumberOfVisited] = useState(0);\r\n  const { numberOfPixel, pixelSize, wallSize } = props;\r\n  const [tracked, setTracked] = useState([0]);\r\n  const canvasRef = useRef(null);\r\n\r\n  function Cell(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.rightWall = false;\r\n    this.downWall = false;\r\n    this.visited = false;\r\n    this.display = () => {\r\n      console.log(this.x, this.y, this.visited);\r\n    };\r\n    this.fillWalls = (side) => {\r\n      const ctx = canvasRef.current.getContext(\"2d\");\r\n      ctx.fillStyle = \"red\";\r\n      if (side === 1) {\r\n        this.rightWall = true;\r\n        ctx.fillRect(this.x + pixelSize, this.y, wallSize, pixelSize);\r\n      } else {\r\n        this.downWall = true;\r\n        ctx.fillRect(this.x, this.y + pixelSize, pixelSize, wallSize);\r\n      }\r\n    };\r\n  }\r\n  useEffect(() => console.log(tracked), [tracked]);\r\n  const findReverse = (index) => {\r\n    const ele = tracked[tracked.length - 2],\r\n      current = tracked[tracked.length - 1];\r\n    console.log(index, ele, current);\r\n    if (ele && ele === index) {\r\n      console.log(\"reverse\");\r\n      const diff = current - ele;\r\n      console.log(diff);\r\n      diff > 0\r\n        ? diff === numberOfPixel\r\n          ? tracker(index, \"red\", true, false)\r\n          : tracker(index, \"red\", true, true)\r\n        : diff === -numberOfPixel\r\n        ? tracker(index, \"red\", true, true)\r\n        : tracker(index, \"red\", false, true);\r\n      setTracked((state) => state.slice(0, state.length - 1));\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n  const tracker = (index, color, loc, dir) => {\r\n    const ctx = canvasRef.current.getContext(\"2d\");\r\n    ctx.fillStyle = color;\r\n    let x = Cells[index].x,\r\n      y = Cells[index].y,\r\n      width = pixelSize,\r\n      height = pixelSize;\r\n    if (loc) {\r\n      if (dir) {\r\n        x += pixelSize;\r\n      } else {\r\n        y += pixelSize;\r\n      }\r\n    }\r\n    if (dir) {\r\n      width += wallSize;\r\n    } else {\r\n      height += wallSize;\r\n    }\r\n    ctx.fillRect(x, y, width, height);\r\n  };\r\n  useEffect(() => {\r\n    return () => {\r\n      if (canvasRef.current !== null) {\r\n        const ctx = canvasRef.current.getContext(\"2d\");\r\n        setRestart(true);\r\n        setCurrent(null);\r\n        setTracked([0, 0]);\r\n        Cells = [];\r\n        props.onEnd(false);\r\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n      }\r\n    };\r\n  }, [numberOfPixel, pixelSize, wallSize]);\r\n  useEffect(() => {\r\n    if (props.left !== 0) {\r\n      const current = tracked[tracked.length - 1];\r\n      if (\r\n        current - 1 > 0 &&\r\n        current % numberOfPixel !== 0 &&\r\n        Cells[current - 1].rightWall &&\r\n        findReverse(current - 1)\r\n      ) {\r\n        tracker(current - 1, \"green\", false, true);\r\n        setTracked((state) => [...state, current - 1]);\r\n      }\r\n    }\r\n  }, [props.left]);\r\n  useEffect(() => {\r\n    if (props.up !== 0) {\r\n      console.log(\"up\");\r\n      const current = tracked[tracked.length - 1];\r\n      if (\r\n        current - numberOfPixel > 0 &&\r\n        Cells[current - numberOfPixel].downWall &&\r\n        findReverse(current - numberOfPixel)\r\n      ) {\r\n        tracker(current - numberOfPixel, \"green\", false, false);\r\n        setTracked((state) => [...state, current - numberOfPixel]);\r\n      }\r\n    }\r\n  }, [props.up]);\r\n\r\n  useEffect(() => {\r\n    if (props.right !== 0) {\r\n      console.log(\"right\");\r\n      const current = tracked[tracked.length - 1];\r\n      if (\r\n        Cells[current].rightWall &&\r\n        current + 1 < numberOfPixel ** 2 &&\r\n        (current + 1) % numberOfPixel !== 0 &&\r\n        findReverse(current + 1)\r\n      ) {\r\n        tracker(current, \"green\", true, true);\r\n        setTracked((state) => [...state, current + 1]);\r\n      }\r\n    }\r\n  }, [props.right]);\r\n  useEffect(() => {\r\n    if (props.down !== 0) {\r\n      console.log(\"down\");\r\n      const current = tracked[tracked.length - 1];\r\n      if (\r\n        Cells[current].downWall &&\r\n        current + numberOfPixel < numberOfPixel ** 2 &&\r\n        findReverse(current + numberOfPixel)\r\n      ) {\r\n        tracker(current, \"green\", true, false);\r\n        setTracked((state) => [...state, current + numberOfPixel]);\r\n      }\r\n    }\r\n  }, [props.down]);\r\n  const findNeighbours = (index) => {\r\n    const neighbours = [];\r\n    if (index - numberOfPixel > 0) {\r\n      neighbours.push(index - numberOfPixel);\r\n    }\r\n    if (index + numberOfPixel < numberOfPixel ** 2) {\r\n      neighbours.push(index + numberOfPixel);\r\n    }\r\n    if (index - 1 > 0 && index % numberOfPixel !== 0) {\r\n      neighbours.push(index - 1);\r\n    }\r\n    if (index + 1 < numberOfPixel ** 2 && (index + 1) % numberOfPixel !== 0) {\r\n      neighbours.push(index + 1);\r\n    }\r\n    return neighbours.filter((ele) => {\r\n      if (Cells.length) {\r\n        return Cells[ele].visited !== true;\r\n      }\r\n      return true;\r\n    });\r\n  };\r\n  const removeWalls = (current, next) => {\r\n    const difference = next - current;\r\n    if (difference === 1) {\r\n      Cells[current].fillWalls(1);\r\n    } else if (difference === -1) {\r\n      Cells[next].fillWalls(1);\r\n    } else if (difference > 0) {\r\n      Cells[current].fillWalls(-1);\r\n    } else {\r\n      Cells[next].fillWalls(-1);\r\n    }\r\n  };\r\n  const mazeController = () => {\r\n    const ctx = canvasRef.current.getContext(\"2d\");\r\n    ctx.fillStyle = \"green\";\r\n    ctx.fillRect(0, 0, pixelSize, pixelSize);\r\n    ctx.fillStyle = \"blue\";\r\n    ctx.fillRect(\r\n      numberOfPixel * (wallSize + pixelSize) - pixelSize,\r\n      numberOfPixel * (wallSize + pixelSize) - pixelSize,\r\n      pixelSize,\r\n      pixelSize\r\n    );\r\n  };\r\n  const mazeGenerator = (index) => {\r\n    const neighbours = findNeighbours(index);\r\n    if (numberOfVisited === numberOfPixel ** 2 - 1) {\r\n      console.log(\"end\");\r\n      mazeController();\r\n      props.onEnd(true);\r\n      return;\r\n    }\r\n    //STEP 2.1\r\n    if (neighbours.length != 0) {\r\n      //STEP 2.1.1\r\n      const random = Math.floor(Math.random() * neighbours.length);\r\n      const selected = neighbours[random];\r\n      //STEP 2.1.2\r\n      setStack((state) => [...state, index]);\r\n      //STEP 2.1.3\r\n      removeWalls(index, selected);\r\n      if (Cells[selected].visited === false) {\r\n        setNumberOfVisited((state) => state + 1);\r\n      }\r\n      Cells[selected].visited = true;\r\n      setTimeout(() => setCurrent(selected), 10);\r\n    } else if (stack.length > 0) {\r\n      const last = stack[stack.length - 1];\r\n      const newStack = stack.slice(0, stack.length - 1);\r\n      setStack((state) => newStack);\r\n      setTimeout(() => setCurrent(last), 10);\r\n    }\r\n  };\r\n  useEffect(() => {\r\n    if (current !== null) {\r\n      mazeGenerator(current);\r\n    }\r\n  }, [current]);\r\n\r\n  useEffect(() => {\r\n    if (restart != null) {\r\n      const canvas = canvasRef.current;\r\n      const ctx = canvas.getContext(\"2d\");\r\n      setRestart(null);\r\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n      ctx.fillStyle = \"#000000\";\r\n      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n      ctx.fillStyle = \"red\";\r\n      const Pixels = [];\r\n      let spaceH = 0,\r\n        spaceW;\r\n      while (spaceH < ctx.canvas.height) {\r\n        spaceW = 0;\r\n        while (spaceW < ctx.canvas.width) {\r\n          ctx.fillRect(spaceW, spaceH, pixelSize, pixelSize);\r\n          const cell = new Cell(spaceW, spaceH);\r\n          Pixels.push(cell);\r\n          spaceW += pixelSize + wallSize;\r\n        }\r\n        spaceH += pixelSize + wallSize;\r\n      }\r\n      Cells = [...Pixels];\r\n      //STEP 1\r\n      setNumberOfVisited(1);\r\n      setCurrent(0);\r\n    }\r\n  }, [restart]);\r\n\r\n  return (\r\n    <canvas\r\n      ref={canvasRef}\r\n      width={(wallSize + pixelSize) * numberOfPixel - wallSize}\r\n      height={(wallSize + pixelSize) * numberOfPixel - wallSize}\r\n    />\r\n  );\r\n};\r\n\r\nexport default NewMaze;\r\n","import { useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport Maze from \"./components/NewMaze\";\nimport styles from \"./Maze.module.css\";\nfunction App() {\n  const [mazeToggle, setMazetoggle] = useState(true);\n  const [showControls, setShowControls] = useState(false);\n  const [up, setUp] = useState(0);\n  const [down, setDown] = useState(0);\n  const [left, setLeft] = useState(0);\n  const [right, setRight] = useState(0);\n  const keyPressHandler = (e) => {\n    const code = e.code;\n    if (code === \"KeyW\") {\n      setUp((state) => state + 1);\n    } else if (code === \"KeyD\") {\n      setRight((state) => state + 1);\n    } else if (code === \"KeyS\") {\n      setDown((state) => state + 1);\n    } else if (code === \"KeyA\") {\n      setLeft((state) => state + 1);\n    }\n  };\n  useEffect(() => {\n    if (showControls) {\n      window.addEventListener(\"keypress\", keyPressHandler);\n    }\n    return () => window.removeEventListener(\"keypress\", keyPressHandler);\n  }, [showControls]);\n  return (\n    <div className=\"App\" onKeyDown={(e) => console.log(\"ckjaj\")}>\n      <Maze\n        numberOfPixel={30}\n        pixelSize={20}\n        wallSize={4}\n        mazeState={mazeToggle}\n        onEnd={(state) => setShowControls(state)}\n        up={up}\n        down={down}\n        left={left}\n        right={right}\n      />\n      {showControls ? (\n        <div>\n          <div className={styles.row}>\n            <button\n              className={styles.but}\n              onClick={() => setUp((state) => state + 1)}\n            >\n              up\n            </button>\n          </div>\n          <div className={styles.row}>\n            <button\n              className={styles.but}\n              onClick={() => setLeft((state) => state + 1)}\n            >\n              left\n            </button>\n            <button\n              className={styles.but}\n              onClick={() => setDown((state) => state + 1)}\n            >\n              bottom\n            </button>\n            <button\n              className={styles.but}\n              onClick={() => setRight((state) => state + 1)}\n            >\n              right\n            </button>\n          </div>\n        </div>\n      ) : null}\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"row\":\"Maze_row__1uNhP\",\"but\":\"Maze_but__EIOX3\"};"],"sourceRoot":""}